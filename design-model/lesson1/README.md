# 策略模式



## 示例

我们通过一个示例来讨论策略模式：

假如我们现在需要开发一款模拟鸭子游戏：SimUDuck。游戏中有各种鸭子，一边游泳戏水，一边叫唤。此时我们设计了一套系统，具体参考[lesson1.first](https://github.com/yancongcong1/study-log/tree/master/design-model/code/src/main/java/lesson1/first)：

我们设计了一个鸭子的父类，父类拥有一些方法，quack，swim，display(外观)，所有的鸭子都继承自父类，之后，任务被很好的完成了。

-----------------------------------------------------------------------------------

一年之后，由于竞争压力太大，主管认为是时候创新了，所以他决定我们的鸭子需要会飞......，这时候大家一看都很自信，3天之内任务就搞定了，主管很高兴。但是，可怕的问题发生了，股东突然给主管打了一个电话因为他在屏幕上看到了我们会飞的橡皮鸭子。我们大家都忽略了一件事情，那就是不是所有的鸭子都会飞。

这时候对代码所做的局部修改，影响的可不仅仅是局部啊。

此时大家也体会到了一个道理：**当涉及到维护时，为了复用而使用继承使得结局并不完美。**

大家想到了一个可能的解决办法，那就是使用继承，然后再橡皮鸭中覆盖fly方法，使得它什么都不做，但是这个答案马上就被否决了因为某个人偷偷看到了主管备忘录上写了打算1个月更新一次产品。如果每次有新鸭子出现，那简直是个噩梦。所以，我们决定设计一个更加清楚的方法，让某些鸭子可以特定做某事。根据这个我们又设计了一套系统，具体参考[lesson1.second](https://github.com/yancongcong1/study-log/tree/master/design-model/code/src/main/java/lesson1/second):

将飞行和叫唤抽象成接口，只让那些可以进行这些动作的鸭子实现这些接口，至此我们的功能好像完成了。

----------

但是方案交给主管后就被打了回来，因为他觉得重复的代码实在是太多了，当我们快要崩溃的时候，有一个高手告诉了我们这样一个原则：

**找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。**

我们知道Duck类中的fly和quack方法会随着鸭子的不同而改变，所以根据原则我们把它们提起出来。

这时候我们又收到了第二条原则：

**针对接口编程，而不是针对实现编程。**

所以我们不在在鸭子中实现这些行为接口，而是通过一些专门的类来实现它们。这样的设计，可以让飞行和叫唤的动作被其他对象复用，因为这些行为已经和鸭子类无关了。同时我们也可以新增一些行为，不会影响到基友的行为类，也不会影响使用到飞行行为的鸭子类。

这时候我们通过在Duck类中加入两个实例变量来整合鸭子的行为，通过在构造器中赋予它们不同的实例来主导鸭子的不同行为(细心的同学可能发现了这个属于针对实现编程，后面的模式会修正这个问题)。同时我们还可以通过set方法来动态的修改鸭子的行为。具体参考[lesson1.third](https://github.com/yancongcong1/study-log/tree/master/design-model/code/src/main/java/lesson1/third)。

根据我们的实战经验，我们会发现，有时候有一个可能比是一个更加好一点(比如动态改变鸭子的行为)，这就是我们今天学到的另一个原则：

**多用组合，少用继承。**



## 总结

程序设计的基础：

- 抽象
- 继承
- 多态
- 封装

程序设计原则：

- 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
- 针对接口编程，而不是针对实现编程
- 多用组合，少用继承(可以将多个类组合起来使用而不是继承它们，通过将行为委托给他们来实现需求)

**策略模式----定义算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立鱼使用算法的客户。**